<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>luker.dev | Testing Visual Studio Code Extensions</title>
    <meta name="author" content="Ryan Luker">
    <meta name="description" content="Testing Visual Studio Code Extensions">
    <link rel="stylesheet" type="text/css" href="/basic.css">
  </head>
  <body>
    <div>
      <h1>
        <a href="/home">luker.dev</a>
      </h1>
    </div>
    <h3>How to unit test vscode extensions with basic mocks</h3>
    <p>
      One of the major tools in any testers toolbelt is the mighty module mock. 
      So when I started looking into adding proper unit tests to my vscode extension, 
      I surprisingly had quite a difficult time finding something that would work gracefully 
      with vscode’s test harness. Seeming I have also been tinkering with go and the absolutely 
      fantastic gitbook <a href="https://quii.gitbook.io/learn-go-with-tests/">learn-go-with-tests</a>, 
      I decided to try my hand at creating a simple mocking structure for 
      <a href="https://github.com/ryanluker/vscode-coverage-gutters">vscode-coverage-gutters</a>. 
      This was in contrast to using something established like <a href="https://sinonjs.org">sinon</a>. 
      Big warning before I dive in though, this implementation works well for this specific use case but should 
      not be taken as vscode extension testing gospel!
    </p>
    <p>Let’s quickly breakdown the problem before we go into our very basic mocking implementation.</p>
    <ol>
      <li>We need a way to mock module functionality that are used inside our extension (vscode, requests, etc).</li>
      <li>We need to swap the current functionality of the module with our test expectation</li>
      <li>Once we have completed a test case, we need to clean up after ourselves to prevent test leakage.</li>
    </ol>
    <p>
      Alright, with our requirements outlined let’s dive in! The first critical piece of understanding is how we 
      can mock modules inside the test case without directly affecting the piece of code under test. This is where 
      having an understanding of the nodejs import 
      <a href="https://nodejs.org/api/modules.html#modules_caching">caching system</a> 
      comes into play. Using the cache ,to effect extension wide changes, we can do something like this for mocking 
      the <code>fs.readFile</code>.
    </p>
    <code>
      import * as assert from "assert";
      import * as fs from "fs";

      // Original functions
      const readFile = fs.readFile;

      teardown(function() {
          (fs as any).readFile = readFile;
      });

      test("#load: Should reject when readFile returns an error @unit", function(done) {
          const readFile = function(path: string, cb) {
              assert.equal(path, "pathtofile");
              const error: NodeJS.ErrnoException = new Error("could not read from fs");
              return cb(error, Buffer.from(""));
          };
          (fs as any).readFile = readFile;

          const coverage = new Coverage(
              fakeConfig,
          );
      });
    </code>
    <a href="https://github.com/ryanluker/luker.dev/discussions/13">Discussion</a>
  </body>
</html>
